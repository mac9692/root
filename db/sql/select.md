```aiignore
프로그래머스 : 12세 이하인 여자 환자 목록 출력하기

SELECT PT_NAME
, PT_NO
, GEND_CD
, AGE
, COALESCE(TLNO, 'NONE') AS TLNO
FROM PATIENT
WHERE GEND_CD = 'W'
AND AGE < 13
ORDER BY AGE DESC, PT_NAME ASC
```

```aiignore
프로그래머스 : 재구매가 일어난 상품과 회원 리스트 구하기

SELECT USER_ID
, PRODUCT_ID
FROM ONLINE_SALE
GROUP BY USER_ID, PRODUCT_ID
HAVING COUNT(1) > 1
ORDER BY USER_ID ASC, PRODUCT_ID DESC
```

```aiignore
프로그래머스 : 역순 정렬하기

SELECT NAME
, DATETIME
FROM ANIMAL_INS
ORDER BY ANIMAL_ID DESC
```

```aiignore
프로그래머스 : 아픈 동물 찾기

SELECT ANIMAL_ID
, NAME
FROM ANIMAL_INS
WHERE INTAKE_CONDITION = 'Sick'
ORDER BY ANIMAL_ID
```

```aiignore
프로그래머스 : 어린 동물 찾기

SELECT ANIMAL_ID
, NAME
FROM ANIMAL_INS
WHERE INTAKE_CONDITION != 'Aged'
ORDER BY ANIMAL_ID
```

```aiignore
프로그래머스 : 가장 큰 물고기 10마리 구하기

SELECT ID
, LENGTH
FROM FISH_INFO
WHERE LENGTH > 10
ORDER BY LENGTH DESC, ID
LIMIT 10
```

```aiignore
프로그래머스 : 특정 물고기를 잡은 총 수 구하기

SELECT COUNT(1) AS "FISH_COUNT"
FROM FISH_INFO A
INNER JOIN FISH_NAME_INFO B ON A.FISH_TYPE = B.FISH_TYPE
WHERE B.FISH_NAME IN ("BASS", "SNAPPER") 
```

```aiignore
프로그래머스 : 대장균들의 자식의 수 구하기

SELECT A.ID
, COUNT(B.ID) AS "CHILD_COUNT"
FROM ECOLI_DATA A
LEFT OUTER JOIN ECOLI_DATA B ON A.ID = B.PARENT_ID
GROUP BY A.ID
ORDER BY ID
```

```aiignore
프로그래머스 : 대장균의 크기에 따라 분류하기 1

SELECT ID
, CASE WHEN SIZE_OF_COLONY < 101 THEN "LOW"
WHEN SIZE_OF_COLONY > 100 AND SIZE_OF_COLONY < 1001 THEN "MEDIUM"
WHEN SIZE_OF_COLONY > 1000 THEN "HIGH"
END AS 'SIZE'
FROM ECOLI_DATA
ORDER BY ID
```

```aiignore
프로그래머스 : 이름이 있는 동물의 아이디

SELECT ANIMAL_ID
FROM ANIMAL_INS
WHERE NAME IS NOT NULL
ORDER BY ANIMAL_ID
```

```aiignore
프로그래머스 : 조건에 맞는 아이템들의 가격의 총합 구하기

SELECT SUM(PRICE) AS "TOTAL_PRICE"
FROM ITEM_INFO
WHERE RARITY = "LEGEND"
```

```aiignore
프로그래머스 : 잡은 물고기 중 가장 큰 물고기의 길이 구하기

SELECT CONCAT(COALESCE(MAX(LENGTH), 0), "cm") AS 'MAX_LENGTH'
FROM FISH_INFO
WHERE LENGTH IS NOT NULL
```

```aiignore
프로그래머스 : 조건에 맞는 사원 정보 조회하기

SELECT SUM(B.SCORE) AS "SCORE"
, A.EMP_NO
, A.EMP_NAME
, A.POSITION
, A.EMAIL
FROM HR_EMPLOYEES A INNER JOIN HR_GRADE B ON A.EMP_NO = B.EMP_NO
GROUP BY A.EMP_NO
ORDER BY SCORE DESC
LIMIT 1

SELECT A.SCORE
, A.EMP_NO
, B.EMP_NAME
, B.POSITION
, B.EMAIL
FROM (
SELECT EMP_NO, SUM(SCORE) AS "SCORE"
    FROM HR_GRADE 
    GROUP BY EMP_NO
) A INNER JOIN HR_EMPLOYEES B ON A.EMP_NO = B.EMP_NO
ORDER BY SCORE DESC
LIMIT 1
```