```aiignore
프로그래머스 : 조건에 맞는 사용자 정보 조회하기

SELECT U.USER_ID
, U.NICKNAME
, CONCAT(U.CITY, ' ', U.STREET_ADDRESS1, ' ', U.STREET_ADDRESS2) AS "전체주소"
, CONCAT(SUBSTR(U.TLNO, 1, 3), '-', SUBSTR(U.TLNO, 4, 4), '-', SUBSTR(U.TLNO, 8, 4)) AS "전화번호"
FROM USED_GOODS_BOARD B
LEFT JOIN USED_GOODS_USER AS U
ON U.USER_ID = B.WRITER_ID
GROUP BY B.WRITER_ID
HAVING COUNT(*) >= 3
ORDER BY U.USER_ID DESC
```

```aiignore
프로그래머스 : 루시와 엘라 찾기

SELECT A.ANIMAL_ID
, A.NAME
, A.SEX_UPON_INTAKE
FROM ANIMAL_INS A
WHERE A.NAME IN ('Lucy', 'Ella', 'Pickle', 'Rogan', 'Sabrina', 'Mitty')
ORDER BY A.ANIMAL_ID
```

```aiignore
프로그래머스 : 카테고리 별 도서 판매량 집계하기

SELECT B.CATEGORY
, SUM(COALESCE(S.SALES, 0)) AS TOTAL_SALES
FROM BOOK B
LEFT JOIN BOOK_SALES S
ON B.BOOK_ID = S.BOOK_ID
WHERE S.SALES_DATE >= '2022-01-01' AND 
S.SALES_DATE < '2022-02-01'
GROUP BY B.CATEGORY
ORDER BY B.CATEGORY

SELECT B.CATEGORY
, SUM(COALESCE(S.SALES, 0)) AS TOTAL_SALES
FROM BOOK B
LEFT JOIN BOOK_SALES S
ON B.BOOK_ID = S.BOOK_ID
WHERE S.SALES_DATE BETWEEN '2022-01-01' AND '2022-01-31'
GROUP BY B.CATEGORY
ORDER BY B.CATEGORY
```

```aiignore
프로그래머스 : 즐겨찾기가 가장 많은 식당 정보 출력하기

SELECT FOOD_TYPE
, REST_ID
, REST_NAME
, FAVORITES
FROM REST_INFO
WHERE (FOOD_TYPE, FAVORITES) IN (
SELECT FOOD_TYPE, MAX(FAVORITES) FROM REST_INFO
    GROUP BY FOOD_TYPE
)
ORDER BY FOOD_TYPE DESC

SELECT FOOD_TYPE
, REST_ID
, REST_NAME
, FAVORITES
FROM (
SELECT FOOD_TYPE
, REST_ID
, REST_NAME
, FAVORITES
, RANK() OVER (PARTITION BY FOOD_TYPE ORDER BY FAVORITES DESC) AS RNK
FROM REST_INFO
    ) AS A
WHERE RNK = 1
ORDER BY FOOD_TYPE DESC
```

```aiignore
프로그래머스 : 고양이와 개는 몇 마리 있을까

SELECT ANIMAL_TYPE
, COUNT(1) count
FROM ANIMAL_INS
WHERE ANIMAL_TYPE IN ('Cat', 'Dog')
GROUP BY ANIMAL_TYPE
ORDER BY ANIMAL_TYPE
```

```aiignore
프로그래머스 : 동명 동물 수 찾기

SELECT NAME
, COUNT(1) AS COUNT
FROM ANIMAL_INS 
WHERE NAME IS NOT NULL
GROUP BY NAME
HAVING COUNT(1) >= 2
ORDER BY NAME
```

```aiignore
프로그래머스 : 조건별로 분류하여 주문상태 출력하기

SELECT ORDER_ID
, PRODUCT_ID
, DATE_FORMAT(OUT_DATE, '%Y-%m-%d')
, CASE WHEN OUT_DATE <= '2022-05-01' THEN '출고완료'
WHEN OUT_DATE > '2022-05-01' THEN '출고대기'
ELSE '출고미정' END AS 출고여부
FROM FOOD_ORDER
ORDER BY ORDER_ID
```

```aiignore
프로그래머스 : 이름에 el이 들어가는 동물 찾기

SELECT ANIMAL_ID
, NAME
FROM ANIMAL_INS 
WHERE UPPER(NAME) LIKE '%EL%'
AND ANIMAL_TYPE = 'Dog'
ORDER BY NAME
```

```aiignore
프로그래머스 : 없어진 기록 찾기

SELECT O.ANIMAL_ID
, O.NAME
FROM ANIMAL_OUTS O
LEFT JOIN ANIMAL_INS I
ON O.ANIMAL_ID = I.ANIMAL_ID
WHERE I.ANIMAL_ID IS NULL
ORDER BY O.ANIMAL_ID
```

```aiignore
프로그래머스 : 있었는데요 없었습니다

SELECT I.ANIMAL_ID
, I.NAME
FROM ANIMAL_INS I
INNER JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE I.DATETIME > O.DATETIME
ORDER BY I.DATETIME
```

```aiignore
프로그래머스 : 서울에 위치한 식당 목록 출력하기

SELECT A.REST_ID
, A.REST_NAME
, A.FOOD_TYPE
, A.FAVORITES
, A.ADDRESS
, B.AVG_REVIEW AS SCORE
FROM REST_INFO A
INNER JOIN (SELECT REST_ID, ROUND(AVG(REVIEW_SCORE), 2) AS AVG_REVIEW
            FROM REST_REVIEW
            GROUP BY REST_ID) B
ON A.REST_ID = B.REST_ID
WHERE A.ADDRESS LIKE '서울%'
ORDER BY SCORE DESC, A.FAVORITES DESC;
```